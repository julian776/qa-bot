Python Programming Best Practices

Python is a versatile, high-level programming language known for its simplicity and readability. Following best practices ensures your code is maintainable, efficient, and follows industry standards.

Code Style and Formatting:

1. Follow PEP 8: Python's official style guide
2. Use meaningful variable and function names
3. Keep lines under 79 characters
4. Use 4 spaces for indentation (never tabs)
5. Use blank lines to separate functions and classes
6. Use docstrings for functions, classes, and modules

Example of good Python style:

```python
def calculate_user_score(user_id: int, activity_data: dict) -> float:
    """
    Calculate a user's activity score based on their engagement.
    
    Args:
        user_id: Unique identifier for the user
        activity_data: Dictionary containing user activity metrics
        
    Returns:
        Calculated score as a float
    """
    if not activity_data:
        return 0.0
    
    base_score = activity_data.get('base_score', 0)
    multiplier = activity_data.get('multiplier', 1.0)
    
    return base_score * multiplier
```

Type Hints and Annotations:

- Use type hints to improve code readability and catch errors early
- Use typing module for complex types
- Use Optional for values that can be None
- Use Union for values that can be multiple types

```python
from typing import List, Dict, Optional, Union

def process_data(
    items: List[str], 
    config: Optional[Dict[str, str]] = None
) -> Union[str, None]:
    """Process a list of items with optional configuration."""
    if not items:
        return None
    
    # Processing logic here
    return "processed"
```

Error Handling:

1. Use specific exception types
2. Don't use bare except clauses
3. Use try-except-else-finally appropriately
4. Log errors appropriately
5. Use custom exceptions for business logic

```python
import logging

logger = logging.getLogger(__name__)

def safe_divide(a: float, b: float) -> float:
    """Safely divide two numbers."""
    try:
        result = a / b
    except ZeroDivisionError:
        logger.error("Division by zero attempted")
        raise ValueError("Cannot divide by zero")
    except TypeError as e:
        logger.error(f"Invalid input types: {e}")
        raise ValueError("Inputs must be numbers")
    else:
        logger.info(f"Division successful: {a} / {b} = {result}")
        return result
```

Data Structures and Algorithms:

1. Choose appropriate data structures for your use case
2. Use list comprehensions for simple transformations
3. Use generators for memory-efficient iteration
4. Use collections module for specialized containers
5. Understand time and space complexity

```python
from collections import defaultdict, Counter

# Use defaultdict for cleaner code
word_counts = defaultdict(int)
for word in words:
    word_counts[word] += 1

# Use Counter for counting
word_counts = Counter(words)

# Use list comprehensions
squares = [x**2 for x in range(10) if x % 2 == 0]

# Use generators for memory efficiency
def fibonacci(n):
    a, b = 0, 1
    for _ in range(n):
        yield a
        a, b = b, a + b
```

Object-Oriented Programming:

1. Use classes when you need to maintain state
2. Follow the single responsibility principle
3. Use properties for computed attributes
4. Use dataclasses for simple data containers
5. Implement proper inheritance hierarchies

```python
from dataclasses import dataclass
from typing import List

@dataclass
class User:
    """Represents a user in the system."""
    id: int
    name: str
    email: str
    is_active: bool = True
    
    def __post_init__(self):
        """Validate user data after initialization."""
        if not self.email or '@' not in self.email:
            raise ValueError("Invalid email address")

class UserManager:
    """Manages user operations."""
    
    def __init__(self):
        self.users: List[User] = []
    
    def add_user(self, user: User) -> None:
        """Add a new user to the system."""
        if any(u.id == user.id for u in self.users):
            raise ValueError("User ID already exists")
        self.users.append(user)
    
    def get_user(self, user_id: int) -> User:
        """Get user by ID."""
        for user in self.users:
            if user.id == user_id:
                return user
        raise ValueError("User not found")
```

Testing:

1. Write tests for all public functions and methods
2. Use pytest for testing framework
3. Test edge cases and error conditions
4. Use fixtures for test data setup
5. Aim for high test coverage

```python
import pytest
from unittest.mock import Mock

def test_safe_divide():
    """Test the safe_divide function."""
    assert safe_divide(10, 2) == 5.0
    assert safe_divide(0, 5) == 0.0
    
    with pytest.raises(ValueError, match="Cannot divide by zero"):
        safe_divide(10, 0)
    
    with pytest.raises(ValueError, match="Inputs must be numbers"):
        safe_divide("10", 2)

@pytest.fixture
def sample_user():
    """Create a sample user for testing."""
    return User(id=1, name="Test User", email="test@example.com")

def test_user_creation(sample_user):
    """Test user creation."""
    assert sample_user.id == 1
    assert sample_user.name == "Test User"
    assert sample_user.is_active is True
```

Performance Optimization:

1. Profile your code to identify bottlenecks
2. Use appropriate data structures
3. Avoid premature optimization
4. Use built-in functions when possible
5. Consider using NumPy for numerical computations

```python
# Use built-in functions
total = sum(numbers)  # Better than manual loop

# Use list comprehensions
filtered = [x for x in items if x > 0]  # More efficient than filter()

# Use generators for large datasets
def process_large_file(filename):
    with open(filename) as f:
        for line in f:
            yield process_line(line)
```

Security Best Practices:

1. Validate all input data
2. Use parameterized queries for databases
3. Avoid using eval() and exec()
4. Keep dependencies updated
5. Use environment variables for secrets

```python
import os
from pathlib import Path

# Use environment variables for configuration
DATABASE_URL = os.getenv('DATABASE_URL', 'sqlite:///default.db')
API_KEY = os.getenv('API_KEY')

# Validate file paths
def safe_file_read(filename: str) -> str:
    """Safely read a file with path validation."""
    path = Path(filename)
    if not path.exists():
        raise FileNotFoundError(f"File not found: {filename}")
    
    if not path.is_file():
        raise ValueError(f"Path is not a file: {filename}")
    
    return path.read_text()
```

Documentation and Comments:

1. Write clear docstrings for all functions and classes
2. Use comments to explain why, not what
3. Keep documentation up to date
4. Use type hints to improve documentation
5. Include examples in docstrings

```python
def merge_sorted_lists(list1: List[int], list2: List[int]) -> List[int]:
    """
    Merge two sorted lists into a single sorted list.
    
    This function uses a two-pointer approach for O(n) time complexity.
    
    Args:
        list1: First sorted list of integers
        list2: Second sorted list of integers
        
    Returns:
        Merged sorted list containing all elements from both input lists
        
    Example:
        >>> merge_sorted_lists([1, 3, 5], [2, 4, 6])
        [1, 2, 3, 4, 5, 6]
    """
    # Implementation here
    pass
```

Package Management:

1. Use virtual environments for project isolation
2. Use requirements.txt for dependency management
3. Pin dependency versions for reproducibility
4. Use pip-tools for dependency resolution
5. Consider using Poetry for modern Python projects

```bash
# Create virtual environment
python -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate

# Install dependencies
pip install -r requirements.txt

# Generate requirements.txt
pip freeze > requirements.txt
```

Following these best practices will help you write cleaner, more maintainable, and more efficient Python code. Remember that good code is not just about functionality, but also about readability, maintainability, and collaboration with other developers.
